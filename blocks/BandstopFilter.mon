
package apamax.analyticsbuilder.custom;

using apama.analyticsbuilder.BlockBase;
using apama.analyticsbuilder.Activation;
using com.apama.json.JSONPlugin;
using com.apama.exceptions.Exception;
using com.apama.util.AnyExtractor;
using apama.analyticsbuilder.L10N;
using apamax.analyticsbuilder.samples.WindowContents;
using com.industry.analytics.FFT;
using com.industry.analytics.ComplexType;
using apama.analyticsbuilder.Value;

/** The parameters for the BandstopFilter block. */
event BandstopFilter_$Parameters{

	/**
	** Upper Passband Frequency
	*
	* Only frequencies below the upper passband might be in the output.
	* This is a float, must be a finite value.
	*/
	float upper;

	/**
	** Lower Passband Frequency
	*
	* Only frequencies above the lower passband might be in the output.
	* This is a float, must be a finite value.
	*/
	float lower;
	
	/**
	* Window Duration (secs) 
	*
	* The amount of time in seconds for which signal values are to be kept in the window. 
	* This must be a finite and positive value.
	*/
	float windowDurationSec;

	action $validate() {
		if  (not upper.isFinite()) {
			throw L10N.getLocalizedException("fwk_param_finite_upper_value", [BlockBase.getL10N_param("upper",self),upper]);
		}
		if  (not lower.isFinite()) {
			throw L10N.getLocalizedException("fwk_param_finite_lower_value", [BlockBase.getL10N_param("lower",self),lower]);
		}
		if  (not windowDurationSec.isFinite()) {
			throw L10N.getLocalizedException("fwk_param_finite_windowDurationSec_value", [BlockBase.getL10N_param("windowDurationSec",self),windowDurationSec]);
		}
		if windowDurationSec < 0.0 {
			throw L10N.getLocalizedException("fwk_param_positive_windowDurationSec_value", [BlockBase.getL10N_param("windowDurationSec",self),windowDurationSec]);
		}
	}
}

/** State of the block.*/
event BandstopFilter_$State{
	sequence<WindowContents> contents; //we keep in memory the time-series values received as input. We need to associate the time to each value to work with the rolling window
	float startTime;
}


/**
* Bandstop Filter
*
* Passes signals with a frequency outside the lower and upper range and excludes signals with frequencies inside the range.
* It takes a signal (time-series of float value) as an input, buffer it until it reaches the window duration and then analyze the frequency of that signal.
*
* @$blockCategory Flow Manipulations
*/
event BandstopFilter {

	/**BlockBase object.
	*
	* This is initialized by the framework when the block is required for a model.
	*/
	BlockBase $base;

	/** Parameters, filled in by the framework. */
	BandstopFilter_$Parameters $parameters;
	constant string WINDOW_PROPERTY_NAME := "bandstopFilter";
	
	float upperLimit;
	float lowerLimit;
	float periodSecs;

	/** Called once at block start up. */
	action $init() {
		upperLimit := $parameters.upper;
		lowerLimit := $parameters.lower;
		periodSecs := $parameters.windowDurationSec;
	}

	/**
	*
	* @param $activation The current activation, contextual information required when generating a block output. Blocks should only use the
	* <tt>Activation</tt> object passed to them from the framework, never creating their own or holding on to an <tt>Activation</tt> object.
	*
	* @param $input_value float value to add to the time series.
	*
	* @$inputName value Value
	*/
	action $process(Activation $activation, float $input_value, BandstopFilter_$State $blockState) {
		$base.createTimer(periodSecs, 0.0);
		$blockState.contents.append(WindowContents($input_value, $activation.timestamp));
	}


	/**
	* Called by the framework. Provide the blockstate specific to that partition,
	*
	* This block takes in time series values from which frequencies are then calculated via FFT algo and it filters all frequencies within a specific range.
	*
	*/
	action $timerTriggered(Activation $activation, BandstopFilter_$State $blockState) {
		//if not input then no output
		if $blockState.contents.size() = 0 {return;}

		sequence<WindowContents> timeSeries := $blockState.contents;

		//calculate the start time of the window 
		$blockState.startTime := $activation.timestamp - periodSecs;

		//expire old entries (index 0) that are older than the start of the window.
		while (timeSeries.size() > 0 and timeSeries[0].timestamp < $blockState.startTime) {
			timeSeries.remove(0);
		}

		sequence<decimal> timeSeriesValue := new sequence<decimal>;
		WindowContents wc;
		for wc in timeSeries {
			timeSeriesValue.append((<float> wc.value).toDecimal());
		}
		integer timeRange := (timeSeries[timeSeries.size()-1].timestamp - timeSeries[0].timestamp).floor();
		if timeRange > 0 {
			//The sample size is the number of samples per-second that is used in the FFT calculation. 
			integer sampleSize := timeSeries.size() / timeRange;
			sequence<ComplexType> transformFF := FFT.fft(timeSeriesValue);
			sequence<integer> frequencies := FFT.getFrequencies(sampleSize, transformFF);
			sequence<float> bandStop := new sequence<float>;
			integer f;

			for f in frequencies {
				if f.toFloat() < lowerLimit or f.toFloat() > upperLimit {
					bandStop.append(f.toFloat());
				}
			}
			Value v := new Value;
			v.properties[BandstopFilter.WINDOW_PROPERTY_NAME] := bandStop;
			v.value := true; //has to be set
			$setOutput_filtered($activation, v);
		}
	}


	/**
	* Filtered
	*
	* Populated with frequencies lower than the cut-off.
	*/
	action<Activation,Value> $setOutput_filtered;	// This is initialized by the framework. It sets the output of the block and may trigger any blocks connected to this output.

}